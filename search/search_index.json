{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#github-workflows-kt","title":"github-workflows-kt","text":"<p>github-workflows-kt is a tool for generating GitHub Actions workflow YAML files in a type-safe script, helping you to build robust workflows for your GitHub projects without mistakes, with pleasure, in Kotlin.</p> <p>You won't go back to YAML!</p>"},{"location":"#idea","title":"\ud83d\udca1 Idea","text":"<p>We're often surrounded by YAML configuration. It's a powerful format that provides simple syntax for defining hierarchical data, but it is sometimes used (abused?) to configure complicated scenarios which leads to complicated files that are difficult to write and maintain.</p> <p>Who among us hasn't accidentally used the wrong indentation, missed a possibility to extract a reusable piece of code, or been confused by ambiguous types? The power of a generic-purpose programming language would come in handy in these cases.</p> <p>We're developing github-workflows-kt to solve these and other problems, so you can create GitHub Workflows with confidence.</p>"},{"location":"#benefits","title":"\u2728 Benefits","text":"<ul> <li>no indentation confusion - Kotlin's syntax doesn't rely on it</li> <li>immediate validation - catch bugs early during development, not during runtime</li> <li>strongly typed values - no more confusion about what type is needed for a given parameter</li> <li>superb IDE support - author your workflows in any IDE that supports Kotlin, with auto-completion and documentation   at your fingertips</li> <li>no duplication - don't repeat yourself! Share common configuration using constant values, or define your own   functions to encapsulate logic</li> <li>fully featured language - use the full power of Kotlin to generate workflows dynamically, randomly generate data,   or add custom validation. Defining workflow logic in Kotlin is currently experimental</li> <li>type-safe action bindings - possible to use every action using auto-generated Kotlin bindings</li> <li>integrates with github-actions-typing to use typings   provided by action authors</li> <li>and more!</li> </ul>"},{"location":"faq/","title":"FAQ","text":""},{"location":"faq/#faq","title":"FAQ","text":""},{"location":"faq/#why-do-we-need-the-consistency-check-job","title":"Why do we need the consistency check job?","text":"<p>Each YAML workflow generated by this library by default contains a job that reruns the Kotlin script where the workflow is defined, and ensures that the YAML file stored in the repository matches what is generated in the job.</p> <p>The only valid definition of a GitHub Actions workflow is the YAML-based file. GitHub understand only this representation. In order to provide an alternative representation (here: using Kotlin scripting), we need to have a way of ensuring that whatever is described in the Kotlin scripts matches what is stored in the YAMLs. Otherwise, reading the Kotlin scripts wouldn't reflect what the workflows actually do. The only way of ensuring that e.g. no outdated YAML is run is to check the consistency before the workflow's main logic runs. The consistency check job performs the check directly before the main logic runs, and it's possible to perform this check on demand which is useful e.g. for workflows that aren't triggered in PRs. Adding the consistency check job to the YAML can be disabled, but it's not recommended if correctness is your priority, and should be done if you're sure what you're doing.</p> <p>We realize that this extra runtime step adds certain overhead to the workflows, and that in fact the users of the library compromise their workflows' performance and sometimes sacrifice money (Actions credits) to get more type-safe workflows. We're working on making the situation better, but for now this is the price you need to pay to describe GitHub Actions workflows.</p> <p>We've requested support for alternative ways of defining the workflows, not only in YAML: https://github.com/orgs/community/discussions/15904. However, we only got this answer saying YAML won't go anywhere soon and there are no plans of providing an alternative way.</p>"},{"location":"faq/#why-do-we-need-github-actions-typing-shouldnt-it-be-done-by-github","title":"Why do we need github-actions-typing? Shouldn't it be done by GitHub?","text":"<p>Yes, ideally it should. We've tried contacting GitHub and encouraging them to either introduce this mechanism as a first-party thing, or acknowledge this third-party tool to be recommended by GitHub.</p> <p>See:</p> <ul> <li>a discussion in GitHub community forum: https://github.com/orgs/community/discussions/32054</li> <li>an attempt to add typings for an action owned by GitHub: https://github.com/actions/stale/pull/830</li> <li>an attempt to add typings to the TypeScript action template: https://github.com/actions/typescript-action/pull/744</li> </ul>"},{"location":"faq/#kotlin-scripts-work-as-if-changes-in-the-imported-files-werent-applied-why","title":"Kotlin scripts work as if changes in the imported files weren't applied. Why?","text":"<p>It's a known bug in the Kotlin compiler. In short, only changes in the top-level script trigger recompilation, and changes in the imported scripts make the Kotlin compiler reuse the cached JAR.</p> <p>You can work around it in two ways:</p> <ul> <li>remove the cache whenever needed, before rerunning the modified script. See this comment   to learn where the cache is stored on popular operating systems,</li> <li>disable caching by setting <code>KOTLIN_MAIN_KTS_COMPILED_SCRIPTS_CACHE_DIR</code> to an empty value.</li> </ul> <p>Here's a ticket on the JetBrains side: [KT-42101] Scripts: @file:Import() in kotlin-main-kts uses a stale cache.</p>"},{"location":"faq/#im-getting-an-unexpected-change-in-the-resulting-yaml-in-the-path-to-the-script-in-the-consistency-check-job-why","title":"I'm getting an unexpected change in the resulting YAML, in the path to the script in the consistency check job. Why?","text":"<p>You're most likely affected by another bug related to stale cache. See the previous FAQ item for workarounds.</p> <p>Here's a ticket on the JetBrains side: [KT-64367] Script: stale cache used if FILE is different</p>"},{"location":"faq/#im-having-problems-editing-the-kotlin-based-workflows-in-intellij-why","title":"I'm having problems editing the Kotlin-based workflows in IntelliJ. Why?","text":"<p>Depending on the complexity of your workflows, you may stumble upon some rough edges in how IntelliJ supports Kotlin scripting. It's lagging behind the support provided by Kotlin itself.</p> <p>Here's a list of tickets on the JetBrains side, along with proposed workarounds:</p> <ul> <li> <p>[KTIJ-14580] Imported script are not supported for scripts outside of a source root   It's possible to partially mitigate it by adding dependencies from the imported files directly in the top-level   script.</p> </li> <li> <p>[KTIJ-16532] Scripting: dependencies do not open source files   There are several workarounds: browse the code in GitHub, add a dependency on the library in your main project which   will let you browse the source code in the IDE, or maybe it's enough to use   the rendered API docs.</p> </li> <li> <p>[KTIJ-31203] main.kts script handler uses stale <code>@Repository</code> value to resolve dependencies   When changing <code>@Repository</code> values, close the IntelliJ project and re-open it.   If IntelliJ already resolved the dependency from the old repository, you might need to delete it from the Maven Local   cache repository and after that restart the whole IDE as IntelliJ might not see the recreated file even after   executing the workflow script and the file was recreated in the Maven Local cache repository. (also see next points)</p> </li> <li> <p>A new release of an action added some input, but I don't see it in the IDE   If you depend on a major version of an action like <code>v1</code> and the action adds backwards compatible changes in a new   release that adds inputs, the generated <code>v1</code> bindings are already present in your Maven Local cache repository and   you do not get a new binding generated that includes the new inputs. To work-around this, delete the cache binding   from your Maven Local cache repository, which typically is located at <code>~/.m2/respository/</code>. After that, executing or   syncing the workflow script will re-request a fresh binding from the binding server that will include the up-to-date   state of the action.</p> </li> <li> <p>[KTIJ-31214] Deleting a dependency jar from Maven Local and recreating it leaves <code>*.main.kts</code> script with unresolved symbols until IDE is restarted   After following the previous step and deleting a dependency from the Maven Local cache repository to get it updated,   IntelliJ will not re-resolve the dependency and even doing so in another way like actually executing the workflow   script, IntelliJ still treats the classes as unresolved symbols. To get to a usable state again, you need to restart   the whole IDE, just closing and re-opening the project is not sufficient.</p> </li> </ul>"},{"location":"feature-coverage/","title":"Feature coverage","text":"<p>Here's a list of GitHub Actions features supported by the library, and known to be unsupported yet.</p> <p>Legend:</p> <ul> <li>\u2705 - fully supported</li> <li>\u2705/\u274c - partially supported</li> <li>\u274c - not supported</li> </ul> Feature Support Tracking issue Conditions \u2705 Continue on error \u2705 Concurrency \u2705 Dependent jobs \u2705 Different types of triggers \u2705 Different types of workers \u2705 Environment variables (<code>env</code> context) \u2705 <code>github</code> context \u2705 Job containers \u2705 Job environments \u2705 Docker actions \u2705 Local actions \u2705 <code>outcome</code> context \u2705 Permissions \u2705 Public actions \u2705 <code>runner</code> context \u2705 Strategy matrix (<code>matrix</code> context) \u2705/\u274c #368 Secrets (<code>secrets</code> context) \u2705 Service containers \u2705 Timeouts \u2705 Workflow dispatch inputs (<code>inputs</code> context) \u2705/\u274c #811"},{"location":"projects-using-this-library/","title":"Projects using this library","text":""},{"location":"projects-using-this-library/#projects-using-this-library","title":"Projects using this library","text":"<ul> <li>aSoft-Ltd/oss</li> <li>ComposeOClock</li> <li>course-evals</li> <li>factcast</li> <li>github-actions-typing</li> <li>github-workflows-kt (this library - we dogfood, of course)</li> <li>gradle-release-plugin</li> <li>jEdit</li> <li>Jopiter</li> <li>markout</li> <li>Petals</li> <li>rankquest-studio</li> <li>setup-wsl</li> <li>snakeyaml-engine-kmp</li> <li>Spock</li> <li>spring-cqs</li> <li>twitch-announcement-discord-bot</li> <li>WalletConnectKotlinV2</li> <li>WiertarBot</li> <li>xenosearch</li> <li>feel free to add your project here!</li> </ul>"},{"location":"user-guide/compensating-librarys-missing-features/","title":"Compensating library's missing features","text":""},{"location":"user-guide/compensating-librarys-missing-features/#compensating-librarys-missing-features","title":"Compensating library's missing features","text":"<p>You may find yourself willing to use GitHub Actions' feature that is not yet reflected in this library, neither in the core workflows/jobs/steps API, nor in the action bindings. We've thought about it. The library provides several points of extension so that you can keep using it, and in the meantime report the missing feature to us so that we can add it to one of the next releases. See the below sections to find your specific case.</p> <p>The general approach is that whatever is overridden/customized using the below approaches, takes the precedence over built-in arguments.</p>"},{"location":"user-guide/compensating-librarys-missing-features/#workflows-jobs-and-steps","title":"Workflows, jobs and steps","text":"<p>They have an extra argument - <code>_customArguments</code> - which is a map from <code>String</code> to whatever values or collections are needed, especially using basic types like booleans, strings or integers, and further nesting of maps and lists.</p> <p>For example:</p> <pre><code>workflow(\n    // ...\n    _customArguments =\n        mapOf(\n            \"dry-run\" to true,\n            \"some-string-value\" to \"foobar\",\n            \"written-by\" to listOf(\"Alice\", \"Bob\"),\n            \"concurrency\" to\n                mapOf(\n                    \"group\" to expr(\"github.ref\"),\n                    \"cancel-in-progress\" to \"true\",\n                ),\n        ),\n)\n</code></pre>"},{"location":"user-guide/compensating-librarys-missing-features/#actions-inputs","title":"Action's inputs","text":"<p>Each action binding has an extra constructor parameter - <code>_customInputs</code> - which is a map from <code>String</code> to <code>String</code>:</p> <pre><code>UploadArtifact(\n    // ...\n    _customInputs =\n        mapOf(\n            \"path\" to \"override-path-value\",\n            \"answer\" to \"42\",\n        ),\n)\n</code></pre> <p>You can use it to set inputs that the binding doesn't know about, or to set any custom value if the binding's typing is incorrect or faulty.</p>"},{"location":"user-guide/compensating-librarys-missing-features/#actions-version","title":"Action's version","text":"<p>Each action binding has an extra constructor parameter - <code>_customVersion</code> - which is a string overriding action's version:</p> <pre><code>UploadArtifact(\n    // ...\n    _customVersion = \"v4\",\n)\n</code></pre> <p>It's useful e.g. when the binding doesn't keep up with action's versions and the API is fairly compatible, or if you want to use a specific minor version.</p>"},{"location":"user-guide/compensating-librarys-missing-features/#i-still-cannot-customize-what-i-need","title":"I still cannot customize what I need","text":"<p>Well, it means we missed something - sorry for that! Please report it via GitHub issues.</p>"},{"location":"user-guide/getting_started/","title":"Getting started","text":""},{"location":"user-guide/getting_started/#getting-started","title":"Getting started","text":"<p>As an exercise, we'll add a job that prints out <code>Hello world!</code>. Feel free to replace the actual workflow's logic and all names with your own.</p> <ol> <li>Install Kotlin as a stand-alone binary, e.g. from Snap Store when on Linux:    <pre><code>sudo snap install kotlin --classic\n</code></pre>    Make sure this is the newest version available. Kotlin scripting still has some rough edges, and improvements    are introduced with each new Kotlin release.    Also make sure that you use Java 11+.</li> <li>Create a new executable file in your repository:    <pre><code>touch    .github/workflows/hello_world_workflow.main.kts\nchmod +x .github/workflows/hello_world_workflow.main.kts\n</code></pre>    This location is not a hard requirement, it's just recommended for consistency with enforced location of actual    GitHub Actions workflows.</li> <li>Put this content into the previously created file and save it:    <pre><code>#!/usr/bin/env kotlin\n\n@file:Repository(\"https://repo.maven.apache.org/maven2/\")\n@file:DependsOn(\"io.github.typesafegithub:github-workflows-kt:3.4.0\")\n@file:Repository(\"https://bindings.krzeminski.it\")\n@file:DependsOn(\"actions:checkout:v4\")\n\nimport io.github.typesafegithub.workflows.actions.actions.Checkout\nimport io.github.typesafegithub.workflows.domain.RunnerType.UbuntuLatest\nimport io.github.typesafegithub.workflows.domain.triggers.Push\nimport io.github.typesafegithub.workflows.dsl.workflow\n\nworkflow(\n    name = \"Test workflow\",\n    on = listOf(Push()),\n    sourceFile = __FILE__,\n) {\n    job(id = \"test_job\", runsOn = UbuntuLatest) {\n        uses(name = \"Check out\", action = Checkout())\n        run(name = \"Print greeting\", command = \"echo 'Hello world!'\")\n    }\n}\n</code></pre>    This way we create a workflow with the DSL provided by this library. The reason it needs source    file path is to be able to generate consistency checks, to ensure that both source and target files are in sync.    You'll see it in a moment in the generated file.</li> <li>Generate the YAML by calling the above script:    <pre><code>.github/workflows/hello_world_workflow.main.kts\n</code></pre>    It can be also executed straight from IntelliJ, by clicking the green \u25b6\ufe0f button next to the shebang.    Notice that there's an extra job generated by the library that regenerates the YAML in job's runtime and ensures that    it's equal to the YAML committed to the repository.</li> <li>Commit both files, push the changes to GitHub and make sure the workflow is green when ran on GitHub Actions.</li> <li>Last but not least, feel invited to join the Slack channel    dedicated to this library. You'll find information about upcoming breaking changes, discussion about new features,    and more! If you don't know how to sign up to the Kotlin's Slack space, see here.</li> </ol>"},{"location":"user-guide/job-outputs/","title":"Job outputs","text":""},{"location":"user-guide/job-outputs/#job-outputs","title":"Job outputs","text":"<p>It's possible to pass output from a job in a somewhat type-safe way (that is: types aren't checked, but the field names are).</p> <p>First, define <code>outputs</code> parameter in <code>job</code> function, inheriting from <code>JobOutputs</code>:</p> <pre><code>val myJob =\n    job(\n        id = \"my_job\",\n        runsOn = RunnerType.UbuntuLatest,\n        outputs =\n            object : JobOutputs() {\n                var myOutput by output()\n                var anotherOutput by output()\n            },\n) { ... }\n</code></pre> <p>To set an output from within the job, use <code>jobOutputs</code>, and then an appropriate object field:</p> <pre><code>jobOutputs.myOutput = someStep.outputs.someStepOutput\njobOutputs.anotherOutput = someStep.outputs[\"custom-output\"]\n</code></pre> <p>and then use job's output from another job this way:</p> <pre><code>job(\n    id = \"use_output\",\n    runsOn = RunnerType.UbuntuLatest,\n    needs = listOf(myJob),\n) {\n    run(\n        name = \"Use outputs\",\n        command =\n            \"\"\"\n            echo ${expr { myJob.outputs.myOutput }}\n            echo ${expr { myJob.outputs.anotherOutput }}\n            \"\"\".trimIndent(),\n    )\n}\n</code></pre>"},{"location":"user-guide/migrating-to-Maven-based-bindings/","title":"Migrating to Maven-based bindings","text":""},{"location":"user-guide/migrating-to-Maven-based-bindings/#migrating-to-maven-based-bindings","title":"Migrating to Maven-based bindings","text":""},{"location":"user-guide/migrating-to-Maven-based-bindings/#goal","title":"Goal","text":"<p>Let's say you have the following workflow:</p> <pre><code>#!/usr/bin/env kotlin\n@file:DependsOn(\"io.github.typesafegithub:github-workflows-kt:2.1.0\")\n\nimport io.github.typesafegithub.workflows.actions.actions.CheckoutV4\nimport io.github.typesafegithub.workflows.actions.actions.SetupJavaV3\nimport io.github.typesafegithub.workflows.actions.gradle.ActionsSetupGradleV3\nimport io.github.typesafegithub.workflows.domain.RunnerType.UbuntuLatest\nimport io.github.typesafegithub.workflows.domain.triggers.PullRequest\nimport io.github.typesafegithub.workflows.dsl.workflow\nimport io.github.typesafegithub.workflows.yaml.writeToFile\n\nworkflow(\n    name = \"Build\",\n    on = listOf(PullRequest()),\n    sourceFile = __FILE__,\n) {\n    job(id = \"build\", runsOn = UbuntuLatest) {\n        uses(action = CheckoutV4())\n        uses(action = SetupJavaV3())\n        uses(action = ActionsSetupGradleV3())\n        run(\n            name = \"Build\",\n            command = \"./gradlew build\",\n        )\n    }\n}\n</code></pre> <p><code>CheckoutV4</code>, <code>SetupJavaV3</code> and <code>ActionsSetupGradleV3</code> come with the library - they are shipped together with the DSL. It has a number of downsides:</p> <ul> <li>the library needs to be aware of a certain action, which requires the maintainer's attention</li> <li>getting new versions of the bindings is tied to the release cadence of the library, which is currently   released monthly</li> <li>automatic updates via dependency update bots like Renovate or Dependabot aren't possible</li> </ul> <p>We're going to switch to the new approach where each type-safe action binding is compiled and packaged in a JAR on demand, and is then shipped as a separate Maven artifact from a custom Maven-compatible server.</p>"},{"location":"user-guide/migrating-to-Maven-based-bindings/#required-changes","title":"Required changes","text":"<p>The following changes are required in our example workflow:    </p><pre><code>  #!/usr/bin/env kotlin\n+ @file:Repository(\"https://repo.maven.apache.org/maven2/\")\n  @file:DependsOn(\"io.github.typesafegithub:github-workflows-kt:&lt;newest-version&gt;\")\n+ @file:Repository(\"https://bindings.krzeminski.it\")\n+ @file:DependsOn(\"actions:checkout:v4\")\n+ @file:DependsOn(\"actions:setup-java:v3\")\n+ @file:DependsOn(\"gradle:actions__setup-gradle:v3\")\n\n- import io.github.typesafegithub.workflows.actions.actions.CheckoutV4\n+ import io.github.typesafegithub.workflows.actions.actions.Checkout\n- import io.github.typesafegithub.workflows.actions.actions.SetupJavaV3\n+ import io.github.typesafegithub.workflows.actions.actions.SetupJava\n- import io.github.typesafegithub.workflows.actions.gradle.ActionsSetupGradleV3\n+ import io.github.typesafegithub.workflows.actions.gradle.ActionsSetupGradle\n  import io.github.typesafegithub.workflows.domain.RunnerType.UbuntuLatest\n  import io.github.typesafegithub.workflows.domain.triggers.PullRequest\n  import io.github.typesafegithub.workflows.dsl.workflow\n  import io.github.typesafegithub.workflows.yaml.writeToFile\n\n  workflow(\n      name = \"Build\",\n      on = listOf(PullRequest()),\n      sourceFile = __FILE__,\n  ) {\n      job(id = \"build\", runsOn = UbuntuLatest) {\n-         uses(action = CheckoutV4())\n+         uses(action = Checkout())\n-         uses(action = SetupJavaV3())\n+         uses(action = SetupJava())\n-         uses(action = ActionsSetupGradleV3())\n+         uses(action = ActionsSetupGradle())\n          run(\n              name = \"Build\",\n              command = \"./gradlew build\",\n          )\n      }\n  }\n</code></pre> <p>Then regenerate your YAML to ensure there are no changes.</p>"},{"location":"user-guide/migrating-to-Maven-based-bindings/#remarks","title":"Remarks","text":"<ol> <li>Top-level actions like <code>actions/checkout@v4</code> map to Maven artifacts like <code>actions:checkout:v4</code>. Nested actions like    <code>gradle/actions/setup-gradle@v3</code> require replacing the slash in the middle of the compound name with <code>__</code> (double    underscore) because slash is not allowed in Maven coordinates. Hence, we get <code>gradle:actions__setup-gradle:v3</code>.</li> <li>For inputs with typing information there will now be two properties, a typed one and a <code>String</code>-typed with    <code>_Untyped</code> suffix. You can only set one of those and for required inputs must set exactly one. For inputs that miss    typing information there will only be the <code>_Untyped</code> property with nullability according to required status.</li> <li>If you used <code>_customInputs</code> to set a non-String property to a GitHub Actions expression, you can now instead use    the <code>_Untyped</code> property for that input.</li> <li>If a given binding has incorrect typing, please either ask the action owner to onboard    github-action-typing, or if it's not possible, contribute    to github-actions-typing-catalog.</li> <li>The bindings server currently caches the artifacts for a given owner/name/version tuple for 1 hour    (code).    If you think it's too much/too little, or a different caching strategy would be better, please reach out via GitHub    issues!</li> <li>Regarding dependency update bots, Renovate is able to put updates to the Kotlin script and the YAML in a single PR,    like here. It wasn't tested with Dependabot yet, feel free to    give it a try!</li> </ol>"},{"location":"user-guide/nightly-builds/","title":"Nightly builds","text":""},{"location":"user-guide/nightly-builds/#nightly-builds","title":"Nightly builds","text":"<p>Sometimes you may want to test a change that has been already merged to <code>main</code>, but not yet officially released. In this case, you can use snapshots published for each commit to the <code>main</code> branch.</p> <p>To use a given \"snapshot\" version, e.g. <code>1.3.2-SNAPSHOT</code>, replace your scripts' preamble with:</p> <pre><code>@file:Repository(\"https://s01.oss.sonatype.org/content/repositories/snapshots/\")\n@file:DependsOn(\"io.github.typesafegithub:github-workflows-kt:1.3.2-SNAPSHOT\")\n</code></pre> <p>Remember that requesting version <code>1.3.2-SNAPSHOT</code>, if it's being actively developed, may return a different build of the library each time it's requested. It can also happen occasionally that the snapshot doesn't correspond to any commit on the <code>main</code> branch, and instead some PR that wasn't yet merged. That's why the snapshots are meant to quickly check something simple that wasn't yet released, not for depending on such unstable version constantly.</p>"},{"location":"user-guide/type-safe-expressions/","title":"Type-safe expressions","text":""},{"location":"user-guide/type-safe-expressions/#typesafe-github-expressions","title":"Typesafe GitHub Expressions","text":""},{"location":"user-guide/type-safe-expressions/#github-expressions","title":"GitHub expressions","text":"<p>GitHub supports pretty advanced expressions via the <code>${{ ... }}</code> syntax.</p> <p>They include:</p> <ul> <li>functions</li> <li>environment variables</li> <li>secrets</li> <li>different contexts like the <code>runner</code> or the <code>github</code> context</li> <li>events payloads</li> <li>and more (read here).</li> </ul> <p>Here is an example</p> <pre><code>run(\n    name = \"Environment variable and functions\",\n    command = \"echo \\$GITHUB_ACTORS\",\n    condition = \"\\${{invariably()}}\",\n)\nrun(\n    name = \"GitHubContext echo sha\",\n    command = \"echo commit: \\${{ github.sha256 }}  event: \\${{ github.event.release.zip_url }}\",\n)\n</code></pre> <p>Unfortunately, it is easy to get those expressions wrong.</p> <p>In fact this snippet contains four different errors.</p> <p>Can you spot them all?</p> <p>To make life easier, let us introduce type-safe GitHub expressions.</p>"},{"location":"user-guide/type-safe-expressions/#the-expr-helper-function","title":"The <code>expr(\"\")</code> helper function","text":"<p>First, because <code>\\${{ ... }}</code> is awkward in Kotlin, it can be replaced by the <code>expr(\"\")</code> helper function</p> <pre><code>- \"\\${{invariably()}}\"\n+ expr(\"invariably()\")\n</code></pre> <p>But this is still not type-safe.</p>"},{"location":"user-guide/type-safe-expressions/#type-safe-functions-with-the-expr-dsl","title":"Type-safe functions with the <code>expr { }</code>  DSL","text":"<p>We went one step further towards type-safety by introducing the <code>expr { }</code> DSL.</p> <p>Goals:</p> <ul> <li>an invalid expression should not even compile.</li> <li>increase discoverability of what is available.</li> </ul> <p>For example, you can use auto-completion to find out which functions are available:</p> <p></p> <p>Here we immediately see how to fix a first bug in our original snippet:</p> <pre><code>- \"\\${{invariably()}}\"\n- expr(\"invariably()\")\n+ expr { always() }\n</code></pre> <p>Reference: https://docs.github.com/en/actions/learn-github-actions/expressions#functions</p>"},{"location":"user-guide/type-safe-expressions/#the-runner-context","title":"The <code>runner</code> context","text":"<p>The <code>runner</code> context contains information about the runner that is executing the current job.</p> <p>The possible properties are available via <code>expr { runner.xxx }</code> </p> <p>https://docs.github.com/en/actions/learn-github-actions/contexts#example-contents-of-the-runner-context</p>"},{"location":"user-guide/type-safe-expressions/#the-github-context","title":"The <code>github</code> context","text":"<p>The <code>github</code> context contains information about the workflow run and the event that triggered the run.</p> <p>The possible properties are available via <code>expr { github.xxx }</code></p> <p> Here we detect immediatly another bug in our original snippet</p> <pre><code>-command = \"echo commit: ${'$'}{{ github.sha256 }}\n+command = \"echo commit: \" + expr { github.sha }\n</code></pre> <p>Reference: https://docs.github.com/en/actions/learn-github-actions/contexts#github-context</p>"},{"location":"user-guide/type-safe-expressions/#the-githubeventxxx-payload","title":"The <code>github.eventXXX</code> payload","text":"<p>The <code>github.event</code> field is special because it depends on what kind of events triggered the workflow:</p> <ul> <li>Push</li> <li>PullRequest</li> <li>WorkflowDispatch</li> <li>Release</li> <li>...</li> </ul> <p>Since they have a different type, there is a diferent property <code>expr { github.eventXXX }</code>  per type: </p> <p>By leveraging this feature, we quickly fix another bug in our original snippet:</p> <p></p>"},{"location":"user-guide/type-safe-expressions/#default-environment-variables","title":"Default environment variables","text":"<p>GitHub supports a number of default environment variables.</p> <p>They are available directly in the IDE via the library's <code>Contexts.env</code>  By using this feature in our snippet we would have avoided escaping the dollar and the typo:</p> <pre><code>-command = \"echo \\$GITHUB_ACTORS\",\n+command = \"echo \" + Contexts.env.GITHUB_ACTOR,\n</code></pre> <p>Reference: https://docs.github.com/en/actions/learn-github-actions/environment-variables#default-environment-variables</p>"},{"location":"user-guide/type-safe-expressions/#custom-environment-variables","title":"Custom environment variables","text":"<p>You are not limited to the default environment variables.</p> <p>You can create your own type-safe property by using the syntax</p> <p><code>val MY_VARIABLE_NAME by Contexts.env</code></p> <p>For example:</p> <pre><code>val GREETING by Contexts.env\nval FIRST_NAME by Contexts.env\n\njob(\n    env =\n        mapOf(\n            GREETING to \"World\",\n        ),\n) {\n    run(\n        name = \"Custom environment variable\",\n        env =\n            mapOf(\n                FIRST_NAME to \"Patrick\",\n            ),\n        command = \"echo $GREETING $FIRST_NAME\",\n    )\n}\n</code></pre> <p>Reference: https://docs.github.com/en/actions/learn-github-actions/environment-variables#about-environment-variables</p>"},{"location":"user-guide/type-safe-expressions/#github-secrets","title":"GitHub Secrets","text":"<p>If you have sensitive information, you should store it as a GitHub secret:</p> <p></p> <p>You use them the same way as environment variables, but using <code>Contexts.secrets</code> instead of <code>Contexts.env</code>:</p> <p><code>val SUPER_SECRET by Contexts.secrets</code></p> <p>For example:</p> <pre><code>val SUPER_SECRET by Contexts.secrets\n\nval SECRET by Contexts.env\nval TOKEN by Contexts.env\n\njob(id = \"job1\", runsOn = RunnerType.UbuntuLatest) {\n    run(\n        name = \"Encrypted secret\",\n        env =\n            mapOf(\n                SECRET to expr { SUPER_SECRET },\n                TOKEN to expr { secrets.GITHUB_TOKEN },\n            ),\n        command = \"echo secret=$SECRET token=$TOKEN\",\n    )\n}\n</code></pre>"},{"location":"user-guide/type-safe-expressions/#missing-a-feature","title":"Missing a feature?","text":"<p>GitHub has more contexts that we don't support yet: https://docs.github.com/en/actions/learn-github-actions/contexts</p> <p>There are more <code>github.event</code> payloads that we currently do not support: https://docs.github.com/en/developers/webhooks-and-events/webhooks/webhook-events-and-payloads</p> <p>We feel what we have is a pretty good start, but if you need an additional feature, you can create an issue</p> <p>Or maybe have a look how this type-safe feature is implemented in io.github.typesafegithub.workflows.dsl.expressions and submit a pull request \ud83d\ude4f\ud83c\udffb</p>"},{"location":"user-guide/using-actions/","title":"Using actions","text":""},{"location":"user-guide/using-actions/#using-actions","title":"Using actions","text":"<p>As a reminder, to be able to use an action, you have to know its owner, name and version, e.g. <code>actions/checkout@v3</code>. You can use any action you want. Read on to learn about your options.</p>"},{"location":"user-guide/using-actions/#maven-compatible-action-bindings-repository","title":"Maven-compatible action bindings repository","text":"<p>When to use this approach</p> <p>This is the recommended, default approach. Start with this.</p> <p>To add a dependency on an action:</p> <ol> <li> <p>If you haven't already, add a dependency on a Maven repository that generates the action bindings on the fly:    <code>@file:Repository(\"https://bindings.krzeminski.it\")</code>.</p> </li> <li> <p>Add a dependency on a Maven artifact, e.g. for <code>actions/checkout@v3</code> the right way to add the dependency in the    script is: <code>@file:DependsOn(\"actions:checkout:v3\")</code>. As you can see, the group ID was adopted to model the action's    owner, the artifact ID models the action name, and the version is just action's version (a tag or a branch    corresponding to a released version). If an action's manifest is defined in a subdirectory, like the popular    <code>gradle/actions/setup-gradle@v3</code>, replace the slashes in the action name with <code>__</code>, so in this case it would be    <code>@file:DependsOn(\"gradle:actions__setup-gradle:v3\")</code>.</p> Dealing with stale Maven cache, a.k.a. using version ranges <p>Additionally, the name part can have the suffix <code>___major</code> or <code>___minor</code> (three leading underscores). Without these suffixes if you request a version <code>v1.2.3</code>, the generated YAML will also use exactly <code>v1.2.3</code> unless you use a custom version override. With the <code>___major</code> suffix, it would only write <code>v1</code> to the generated YAML, with the <code>___minor</code> suffix - <code>v1.2</code>.</p> <p>This is especially useful when combined with a version range. The problem with using <code>v1</code> or <code>v1.2</code> is that for GitHub Actions, these are changing tags or changing branches and not static releases. In the Maven world, however, a version that does not end with <code>-SNAPSHOT</code> is considered immutable and is not expected to change. This means that if a new version of the action is released that adds a new input, you cannot use it easily as you still have the old <code>v1</code> artifact in your Maven cache and it will not be updated usually, even though the binding server provides a new binding including the added input. And even if you remove the old version from the Maven cache and get a new version from the bindings server, other people might also have this outdated version in their Maven cache and then fail compilation with your changes. It's worth emphasizing that this problem is currently present only when iterating on your workflows locally. When running on GitHub Actions, this problem doesn't exist because the state of Maven Local repo isn't cached between the runs.</p> <p>To mitigate this problem, you can for example use a dependency like <code>gradle:actions__setup-gradle___major:[v3,v4)</code> (from <code>v3</code> inclusive to <code>v4</code> exclusive). This will resolve to the latest <code>v3.x.y</code> version and thus include any newly added inputs, but still only write <code>v3</code> to the YAML. Without the <code>___major</code> suffix or a not semantically matching range like <code>[v3,v5)</code> or even <code>[v3,v4]</code>, you will get problems with the consistency check as then the YAML output changes as soon as a new version is released. For a minor version you would accordingly use the <code>___minor</code> suffix together with a range like <code>[v4.0,v4.1)</code> to get the latest <code>v4.0</code> release if the action in question provides such a tag or branch.</p> <p>Info</p> <p>If an action maintainer provides pre-releases that follow certain naming conventions as documented in the Maven Documentation, you might need to adjust the upper bound. For exmple a version <code>v4.0-beta</code> is less than <code>v4</code> and thus part of the range <code>[v3,v4)</code>. In such a case - or always, to be on the safe side - you might want to change the range to <code>[v3,v4-alpha)</code>, as the <code>alpha</code> version is the lowest possible version in Maven semantics.</p> </li> <li> <p>Use the action by importing a class like <code>io.github.typesafegithub.workflows.actions.actions.Checkout</code>.</p> </li> </ol> <p>For every action, a binding will be generated. However, some less popular actions don't have typings configured for their inputs, so by default all inputs are of type <code>String</code>, have the suffix <code>_Untyped</code>, and additionally the class name will have an <code>_Untyped</code> suffix. The nullability of the inputs will be according to their required status.</p> <p>There are two ways of configuring typings:</p> <ol> <li> <p>Recommended: a typing manifest (<code>action-typing.yml</code>) in the action's repo, see    github-actions-typing. Thanks to this, the action's owner    is responsible for providing and maintaining the typings defined in a technology-agnostic way, to be used    not only with this Kotlin library. There are also no synchronization issues between the action itself and its    typings. When trying to use a new action that has no typings, always discuss this approach with the action owner    first.</p> </li> <li> <p>Fallback: if it's not possible to host the typings with the action, use    github-actions-typing-catalog,    a community-maintained place to host the typings. You can contribute or fix typings for your favorite action by    sending a PR.</p> </li> </ol> <p>Once there are any typings in place for the action, the <code>_Untyped</code> suffixed class is marked <code>@Deprecated</code>, and a class without that suffix is created additionally. In that class for each input that does not have type information available there will still be only the property with <code>_Untyped</code> suffix and nullability according to required status. For each input that does have type information available, there will still be the <code>_Untyped</code> property and additionally a properly typed property. Both of these properties will be nullable. It is a runtime error to set both of these properties as well as setting none if the input is required. The <code>_Untyped</code> properties are not marked <code>@Deprecated</code>, as it could still make sense to use them, for example if you want to set the value from a GitHub Actions expression.</p> <p>This approach supports dependency updating bots that support Kotlin Script's <code>.main.kts</code> files. E.g. Renovate is known to support it.</p>"},{"location":"user-guide/using-actions/#user-defined-actions","title":"User-defined actions","text":"<p>If you are in a hurry and adding typings is not possible right now, browse these options.</p>"},{"location":"user-guide/using-actions/#typed-binding","title":"Typed binding","text":"<p>When to use this approach</p> <p>It lets you create an action binding in a similar manner that is provided by the action bindings server i.e. a class that takes some constructor arguments with types of your choice, and maps them to strings inside <code>toYamlArguments</code>. Use it to have better type-safety when using the binding.</p>"},{"location":"user-guide/using-actions/#repository-based-actions","title":"Repository based actions","text":"<p>In case of a repository based action which most GitHub actions are, inherit from <code>RegularAction</code> and in case of actions without explicit outputs, use the <code>Actions.Outputs</code> class as type argument:</p> <pre><code>class MyCoolActionV3(\n    private val someArgument: String,\n) : RegularAction&lt;Action.Outputs&gt;(\"acmecorp\", \"cool-action\", \"v3\") {\n    override fun toYamlArguments() =\n        linkedMapOf(\n            \"some-argument\" to someArgument,\n        )\n\n    override fun buildOutputObject(stepId: String) = Outputs(stepId)\n}\n</code></pre> <p>or, in case of actions with explicit outputs, create a subclass of <code>Action.Outputs</code> for the type argument:</p> <pre><code>class MyCoolActionV3(\n    private val someArgument: String,\n) : RegularAction&lt;MyCoolActionV3.Outputs&gt;(\"acmecorp\", \"cool-action\", \"v3\") {\n    override fun toYamlArguments() =\n        linkedMapOf(\n            \"some-argument\" to someArgument,\n        )\n\n    override fun buildOutputObject(stepId: String) = Outputs(stepId)\n\n    class Outputs(\n        stepId: String,\n    ) : Action.Outputs(stepId) {\n        public val coolOutput: String = \"steps.$stepId.outputs.coolOutput\"\n    }\n}\n</code></pre> <p>Once you've got your action, it's now as simple as using it like this:</p> <pre><code>uses(\n    name = \"FooBar\",\n    action = MyCoolActionV3(someArgument = \"foobar\"),\n)\n</code></pre>"},{"location":"user-guide/using-actions/#local-actions","title":"Local actions","text":"<p>In case of a local action you have available in your repository or cloned from a private repository, inherit from <code>LocalAction</code> instead:</p> <pre><code>class MyCoolLocalActionV3(\n    private val someArgument: String,\n) : LocalAction&lt;Action.Outputs&gt;(\"./.github/actions/cool-action\") {\n    override fun toYamlArguments() =\n        linkedMapOf(\n            \"some-argument\" to someArgument,\n        )\n\n    override fun buildOutputObject(stepId: String) = Outputs(stepId)\n}\n</code></pre>"},{"location":"user-guide/using-actions/#published-docker-actions","title":"Published Docker actions","text":"<p>In case of a published Docker action, inherit from <code>DockerAction</code> instead:</p> <pre><code>class MyCoolDockerActionV3(\n    private val someArgument: String,\n) : DockerAction&lt;Action.Outputs&gt;(\"alpine\", \"latest\") {\n    override fun toYamlArguments() =\n        linkedMapOf(\n            \"some-argument\" to someArgument,\n        )\n\n    override fun buildOutputObject(stepId: String) = Outputs(stepId)\n}\n</code></pre>"},{"location":"user-guide/using-actions/#untyped-binding","title":"Untyped binding","text":"<p>When to use this approach</p> <p>It omits typing entirely, and both inputs and outputs are referenced using strings. Use it if you don't care about types because you're in the middle of experimenting. It's also more convenient to produce such code by a code generator.</p>"},{"location":"user-guide/using-actions/#repository-based-actions_1","title":"Repository based actions","text":"<p>In case of a repository based action which most GitHub actions are, use a <code>CustomAction</code>:</p> <pre><code>val customAction =\n    CustomAction(\n        actionOwner = \"xu-cheng\",\n        actionName = \"latex-action\",\n        actionVersion = \"v2\",\n        inputs =\n            mapOf(\n                \"root_file\" to \"report.tex\",\n                \"compiler\" to \"latexmk\",\n            ),\n    )\n</code></pre> <p>If your custom action has outputs, you can access them, albeit in a type-unsafe manner:</p> <pre><code>job(id = \"test_job\", runsOn = RunnerType.UbuntuLatest) {\n    val customActionStep =\n        uses(\n            name = \"Some step with output\",\n            action = customAction,\n        )\n\n    // use your outputs:\n    println(expr(customActionStep.outputs[\"custom-output\"]))\n}\n</code></pre>"},{"location":"user-guide/using-actions/#local-actions_1","title":"Local actions","text":"<p>In case of a local action you have available in your repository or cloned from a private repository, use a <code>CustomLocalAction</code> instead:</p> <pre><code>val customAction =\n    CustomLocalAction(\n        actionPath = \"./.github/actions/setup-build-env\",\n    )\n</code></pre>"},{"location":"user-guide/using-actions/#published-docker-actions_1","title":"Published Docker actions","text":"<p>In case of a published Docker action, use a <code>CustomDockerAction</code> instead:</p> <pre><code>val customAction =\n    CustomDockerAction(\n        actionImage = \"alpine\",\n        actionTag = \"latest\",\n    )\n</code></pre>"}]}