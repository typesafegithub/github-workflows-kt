# Getting started

!!! info "Automatic migration of existing workflows"
    This chapter describes how to start from scratch with something simple, so that you get a gist of how this library
    works. If you prefer to try automatic conversion of your workflows, head over to
    [Script generator](script-generator.md) chapter.

As an exercise, we'll add a job that prints out `Hello world!`. Feel free to replace the actual workflow's logic and all
names with your own.

1. Install Kotlin as a stand-alone binary, e.g. from Snap Store when on Linux:
   ```
   sudo snap install kotlin --classic
   ```
2. Create a new executable file in your repository:
   ```
   touch    .github/workflows/hello_world_workflow.main.kts
   chmod +x .github/workflows/hello_world_workflow.main.kts
   ```
   This location is not a hard requirement, it's just recommended for consistency with enforced location of actual
   GitHub Actions workflows.
3. Put this content into the previously created file and save it:
   ```kotlin
   #!/usr/bin/env kotlin

   @file:DependsOn("it.krzeminski:github-actions-kotlin-dsl:0.12.0")

   import it.krzeminski.githubactions.actions.actions.CheckoutV2
   import it.krzeminski.githubactions.domain.RunnerType.UbuntuLatest
   import it.krzeminski.githubactions.domain.triggers.Push
   import it.krzeminski.githubactions.dsl.workflow
   import it.krzeminski.githubactions.yaml.toYaml
   import java.nio.file.Paths

   val workflow = workflow(
       name = "Test workflow",
       on = listOf(Push()),
       sourceFile = Paths.get(".github/workflows/hello_world_workflow.main.kts"),
       targetFile = Paths.get(".github/workflows/hello_world_workflow.yml")
   ) {
       job(name = "test_job", runsOn = UbuntuLatest) {
           uses(name = "Check out", action = CheckoutV2())
           run(name = "Print greeting", command = "echo 'Hello world!'")
       }
   }

   println(workflow.toYaml())
   ```
   Explanation: first, we create a workflow with the DSL provided by this library. The reason it needs source and target
   file paths is to be able to generate consistency checks, to ensure that both source and target files are in sync.
   You'll see it in a moment in the generated file.What's written to the `workflow` variable is an object of type
   `it.krzeminski.githubactions.domain.Workflow`, it's not a YAML yet. However, a call to `toYaml()` extension function
   does the final piece of job.  
   Alternatively, apart from `toYaml()` which returns a string, there's also `writeToFile()` which puts the string
   straight into the file specified in workflow's `targetFile`. It may come in handy when having a single script generating multiple workflows.
4. Generate the YAML by calling the above script and redirecting its output to the desired YAML file path:
   ```
   .github/workflows/hello_world_workflow.main.kts > .github/workflows/hello_world_workflow.yml
   ```
   Notice that there's an extra job generated by the library that regenerates the YAML in job's runtime and ensures that
   it's equal to the YAML committed to the repository.
5. Commit both files, push the changes to GitHub and make sure the workflow is green when ran on GitHub Actions.
